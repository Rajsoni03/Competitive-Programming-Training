# Binary Tree Inorder Traversal - [Practice - Work@tech](https://workat.tech/problem-solving/practice/binary-tree-inorder-traversal)


Given a binary tree, return the inorder traversal of its elements in vector.


<br>



Example:1
```
Input: 

Output: 

```
Example:2
```
Input: 


Output: 

```

## Solution 1  

Time - O(N)<br>
Space - O(N)

```cpp
/* This is the Node class definition

class Node {
public:
    Node* left;
    Node* right;
    int data;

    Node(int data) {
        this->left = NULL;
        this->right = NULL;
        this->data = data;
    }
};
*/
void inorder(Node *root, vector<int> &ans){
	if (!root) return;
	inorder(root->left, ans);
	ans.push_back(root->data);
	inorder(root->right, ans);	
}

vector<int> getInorderTraversal(Node* root) {
    // add your logic here
	vector<int> ans;
	inorder(root, ans);
	return ans;
}
```

## Solution 2 

Time - O(N)<br>
Space - O(N)

```cpp
/* This is the Node class definition

class Node {
public:
    Node* left;
    Node* right;
    int data;

    Node(int data) {
        this->left = NULL;
        this->right = NULL;
        this->data = data;
    }
};
*/

vector<int> getInorderTraversal(Node* root) {
    // add your logic here
	vector<int> ans;
	stack<Node*> stk;
	Node *n = root;
	
	while(!stk.empty() || n){
		while(n){
			stk.push(n);
			n = n->left;
		}
		ans.push_back(stk.top()->data);
		n = stk.top()->right;
		stk.pop();			
	}
	return ans;
}
```